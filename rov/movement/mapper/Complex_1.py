from numpy import linalg
import numpy as np
import pprint as pp


class Complex():
    """
    This code is a rewrite of MutatorMatrix to simplify and clarify the code without removing the source
    This thrust-mapping works by solving the least squared solution of a system determined by the thrusters locations
    and the directions of the thrusters.
    The system is the 6x8 matrix made of columns of each thrusters affect on each component X, Y, Z. ROLL, PITCH, YAW
    multiplied by the 8x1 thrust map matrix (which we are solving for) equal to the 6x1 desired thrust matrix
    To find the least square solution we find the pseudo-inverse of the 6x8 matrix (A) and multiply both sides of the
    equation by it. If a inverse of the matrix A exists the pseudo-inverse(A) = inverse(A) if not then
    pseudo-inverse(A) * A can be ignored because math leaving
    thrust map matrix = pseudo-inverse(A) * desired thrust
    """
    # X9 Thruster locations and center of mass relative to an arbitrary(?) point converted from inches to meters
    # Each column is X, Y, Z
    X9_THRUSTERS = np.matrix([
		[11.2148, 11.2148, -7.631, -7.631, 6.0419, 6.0419, -2.485, -2.485],
        [-4.7524, 4.7524, -4.7524, 4.7524, -5.5709, 5.5709, -5.5709, 5.5709],
        [0, 0, 0, 0, 5.6384, 5.6384, 5.6384, 5.6384]
    ]) * 0.0254
	
    X9_COM = np.matrix([
        [0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0]
    ]) * 0.0254

    # X and Y component of horizontal thrusters converted to radians to be used by numpy 7pi/18 rad = 70 degrees
    X_COMPONENT = np.sin(7 * np.pi / 18)
    Y_COMPONENT = np.cos(7 * np.pi / 18)

    ROTATION = np.matrix([
        [X_COMPONENT, X_COMPONENT, -X_COMPONENT, -X_COMPONENT, 0, 0, 0, 0],
        [Y_COMPONENT, -Y_COMPONENT, Y_COMPONENT, -Y_COMPONENT, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 1, 1, 1]
    ])
	
    THRUST = np.matrix([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
    POWER = np.matrix([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
	
    FINAL_POWER = np.matrix([0.0])

    def __init__(self):
        self.thruster_layout = np.matrix(Complex.X9_THRUSTERS - Complex.X9_COM)
        # this is the 6x8 matrix that specifies each thrusters contribution on X, Y, Z, Roll, Pitch, Yaw
        self.matrix = None
        # the pseudo inverse of self.matrix used to find the least square solution
        self.pseudo_inverse_matrix = None
        # list of disabled thrusters used to determine when matrix and pseudo_inverse_matrix need to be updated
        self.disabled = [0, 0, 0, 0, 0, 0, 0, 0]
        # The last thrust map returned by the calculate function
        self.map = None

        self.generate_matrix()

    def calculate(self, desired_thrust, disabled_thrusters=None):
        """
        Calculate the needed thrust for each thruster to achieve desired
        :param desired_thrust: The 6 dimensional vector which we want to achieve vector as 6x1 matrix
        :param disabled_thrusters: list of 8 items each corresponding to a thruster (0 meaning enabled, 1 disabled)
        :return: the thrust map generated by solving for the least square solution of the equation
        """
        # In the case of a thruster malfunction this allows for the pseudo_inverse_matrix to be recalculated
        # to account for the thruster that no longer works
        if disabled_thrusters != self.disabled:
            self.disabled = disabled_thrusters
            self.generate_matrix()

        self.map = self.pseudo_inverse_matrix.dot(desired_thrust)

        self.normalize()
        initial_power = self.calc_thrust_power(self.map)
        #limit power if necessary: **scale up power to always be at maximum allowable??
        if initial_power > 960.0:
            FINAL_POWER[0,0] = self.limit_power()
            print('\nPower was limited, force vector changed!')
        else:
            FINAL_POWER[0,0] = initial_power
        return self.map

    def generate_matrix(self):
        """
        Generate the pseudo-inverse of the matrix to be used in the calculation
        :return: the pseud-inverse of self.matrix
        """
        # Calculate the cross product between the location of each thruster and the direction it points in
        rot = np.transpose(np.cross(np.transpose(self.ROTATION), np.transpose(self.thruster_layout), 1))
        self.matrix = np.concatenate((self.ROTATION, rot))
        for thruster in range(8):
            if self.disabled[thruster]:
                self.matrix[:, thruster] = 0.0
        self.pseudo_inverse_matrix = linalg.pinv(self.matrix)
        return self.pseudo_inverse_matrix

    def normalize(self):
        """
        Normalize the values of the thrust map to be in the range [-1, 1] if necessary
        :return: None
        """ 
        max_val = np.amax(np.abs(self.map))
        #if max_val > 1:
        self.map /= max_val

    def limit_power(self):
        """
        Ensure power limit is not exceeded by scaling the thruster values down if necessary
        :return: limitedPower
        """
        limitedPower = self.initial_power
        while limitedPower > 960.0:
            #initialize maxPower as lowest power value 
            maxPower = 0.51
            maxPowerIndex = 0
            for thruster in range(8):
                if self.POWER[0, thruster] > maxPower:
                    maxPower = self.POWER[0, thruster]
                    maxPowerIndex = thruster
            scaleFactor = limitedPower/maxPower
            #scale desired thrust vector and recalculate matrix and power
            self.desired_thrust = scaleFactor * self.desired_thrust
            self.map = self.pseudo_inverse_matrix.dot(desired_thrust)
            self.normalize()
            limitedPower = self.calc_thrust_power(self.map)

    def calc_thrust_power(self, thrusters):
        """
        Find the total power used by all 8 thrusters for given pwm values
        Also calculate the thrust and power for each individual thruster for global variables
        :return: totalPower
        """ 
        # calculate thrust output and power used values for each thruster
        totalPower = 0.0
        for thruster in range(8):
            pwm_output = thrusters[0, thruster]
            self.THRUST[0, thruster] = self.pwm_to_thrust(pwm_output)
            self.POWER[0, thruster] = self.pwm_to_power(pwm_output)
            totalPower = totalPower + self.POWER[0, thruster]

        return totalPower
        
    def pwm_to_thrust(self, pwm):
        """
        Change PWM value to thrust value based on 12V data from thrusters
        :return: Thrust Value (lbf)
        """
        if pwm < -0.05:
            thrust = -3.6529*(pwm**3)-9.8279*(pwm**2)+0.5183*pwm-0.04
        elif pwm > 0.05:
            thrust = -5.9996*(pwm**3)+13.296*(pwm**2)+0.4349*pwm+0.0345
        else:
            thrust = 0
        return thrust

    def pwm_to_power(self, pwm):
        """
        Convert PWM value to power value based on 12V data from thrusters
        :return: Power Value (W)
        """
        if pwm < 0:
            power = -53.282*(pwm**3)+135.58*(pwm**2)+1.1986*pwm+0.51
        else:
            power = 35.949*(pwm**3)+150.51*(pwm**2)-3.0096*pwm+0.51
        return power
        
    def get_results(self):
        """
        Method for returning what the resulting thrust map would cause for the rov based
        on the thruster locations and angles.
        N.B. the normalize function can cause these values to be radically different than the intended. Disable it
             in the calculate function to get more accurate results. If normalized it should be correct just scaled down
        :return: dict of X, Y, Z, Roll, Pitch, Yaw
        """
        res = c.matrix * np.transpose(c.map)
        result = {
            'X': res[0, 0],
            'Y': res[1, 0],
            'Z': res[2, 0],
            'Roll': res[3, 0],
            'Pitch': res[4, 0],
            'Yaw': res[5, 0]
        }
        return result


if __name__ == '__main__':
    c = Complex()
    np.set_printoptions(linewidth=150, suppress=True)
    print('MATRIX')
    pp.pprint(c.matrix)
    print('\nPSEUDO-INVERSE MATRIX')
    pp.pprint(c.pseudo_inverse_matrix)
    print('\nRESULT 8D VECTOR')
    pp.pprint(c.calculate(np.array([1, 0, 1, 0, 0, 0]), [0, 0, 0, 0, 0, 0, 0, 0]))
    print('\nTHRUST')
    pp.pprint(c.THRUST)
    print('POWER')
    pp.pprint(c.POWER)
    print('\nTOTAL POWER')
    pp.pprint(c.FINAL_POWER)
    print('\nRESULTING 6D VECTOR')
pp.pprint(c.get_results())
