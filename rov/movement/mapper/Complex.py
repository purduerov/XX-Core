from BaseMapper import BaseMapper
from numpy import linalg
import numpy as np
import pprint as pp


class Complex(BaseMapper):
    """
    This code is a rewrite of MutatorMatrix to simplify and clarify the code without removing the source

    This thrust-mapping works by solving the least squared solution of a system determined by the thrusters locations
    and the directions of the thrusters.

    The system is the 6x8 matrix made of columns of each thrusters affect on each component X, Y, Z. ROLL, PITCH, YAW
    multiplied by the 8x1 thrust map matrix (which we are solving for) equal to the 6x1 desired thrust matrix

    To find the least square solution we find the pseudo-inverse of the 6x8 matrix (A) and multiply both sides of the
    equation by it. If a inverse of the matrix A exists the pseudo-inverse(A) = inverse(A) if not then
    pseudo-inverse(A) * A can be ignored because math leaving
    thrust map matrix = pseudo-inverse(A) * desired thrust
    """
    # X9 Thruster locations and center of mass relative to an arbitrary(?) point converted from inches to meters
    # Each column is X, Y, Z
    X9_THRUSTERS = np.matrix([
        [5.575, 5.575, -5.575, -5.575, 3.925, 3.925, -2.575, -2.575],
        [-6.59, 6.59, -6.34, 6.34, -7.19, 7.19, -7.19, 7.19],
        [0, 0, 0, 0, 1.95, 1.95, 1.95, 1.95]
    ]) * 0.0254

    X9_COM = np.matrix([
        [0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0]
    ]) * 0.0254

    # X and Y component of horizontal thrusters converted to radians to be used by numpy 7pi/18 rad = 70 degrees
    X_COMPONENT = np.sin(7 * np.pi / 18)
    Y_COMPONENT = np.cos(7 * np.pi / 18)

    ROTATION = np.matrix([
        [X_COMPONENT, X_COMPONENT, -X_COMPONENT, -X_COMPONENT, 0, 0, 0, 0],
        [Y_COMPONENT, -Y_COMPONENT, Y_COMPONENT, -Y_COMPONENT, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 1, 1, 1]
    ])

    def __init__(self):
        self.thruster_layout = np.matrix(Complex.X9_THRUSTERS - Complex.X9_COM)
        # this is the 6x8 matrix that specifies each thrusters contribution on X, Y, Z, Roll, Pitch, Yaw
        self.matrix = None
        # the pseudo inverse of self.matrix used to find the least square solution
        self.pseudo_inverse_matrix = None
        # list of disabled thrusters used to determine when matrix and pseudo_inverse_matrix need to be updated
        self.disabled = [0, 0, 0, 0, 0, 0, 0, 0]
        # The last thrust map returned by the calculate function
        self.map = None

        self.generate_matrix()

    def calculate(self, desired_thrust, disabled_thrusters=None):
        """
        Calculate the needed thrust for each thruster to achieve desired

        :param desired_thrust: The 6 dimensional vector which we want to achieve vector as 6x1 matrix
        :param disabled_thrusters: list of 8 items each corresponding to a thruster (0 meaning enabled, 1 disabled)
        :return: the thrust map generated by solving for the least square solution of the equation
        """
        # In the case of a thruster malfunction this allows for the pseudo_inverse_matrix to be recalculated
        # to account for the thruster that no longer works
        if disabled_thrusters != self.disabled:
            self.disabled = disabled_thrusters
            self.generate_matrix()

        self.map = self.pseudo_inverse_matrix.dot(desired_thrust)

        self.normalize()
        return self.map

    def generate_matrix(self):
        """
        Generate the pseudo-inverse of the matrix to be used in the calculation

        :return: the pseud-inverse of self.matrix
        """
        # Calculate the cross product between the location of each thruster and the direction it points in
        rot = np.transpose(np.cross(np.transpose(self.ROTATION), np.transpose(self.thruster_layout), 1))
        self.matrix = np.concatenate((self.ROTATION, rot))
        for thruster in range(8):
            if self.disabled[thruster]:
                self.matrix[:, thruster] = 0.0

        self.pseudo_inverse_matrix = linalg.pinv(self.matrix)
        return self.pseudo_inverse_matrix

    def normalize(self):
        """
        Normalize the values of the thrust map to be in the range [-1, 1] if necessary
        :return: None
        """
        max_val = np.amax(np.abs(self.map))
        if max_val > 1:
            self.map /= max_val

    def get_results(self):
        """
        Method for returning what the resulting thrust map would cause for the rov based
        on the thruster locations and angles.
        N.B. the normalize function can cause these values to be radically different than the intended. Disable it
             in the calculate function to get more accurate results. If normalized it should be correct just scaled down
        :return: dict of X, Y, Z, Roll, Pitch, Yaw
        """
        res = c.matrix * np.transpose(c.map)
        result = {
            'X': res[0, 0],
            'Y': res[1, 0],
            'Z': res[2, 0],
            'Roll': res[3, 0],
            'Pitch': res[4, 0],
            'Yaw': res[5, 0]
        }
        return result


if __name__ == '__main__':
    c = Complex()
    np.set_printoptions(linewidth=150, suppress=True)
    print('MATRIX')
    pp.pprint(c.matrix)
    print('\nPSEUDO-INVERSE MATRIX')
    pp.pprint(c.pseudo_inverse_matrix)
    print('\nRESULT 8D VECTOR')
    pp.pprint(c.calculate(np.array([1, 1, 0, 0, 0, 1]), [0, 0, 0, 0, 0, 0, 0, 0]))
    print('\nRESULTING 6D VECTOR')
    pp.pprint(c.get_results())
